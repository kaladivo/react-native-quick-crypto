---
phase: 02-secret-derivation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/react-native-quick-crypto/cpp/ecdh/HybridEcdh.hpp
  - packages/react-native-quick-crypto/cpp/ecdh/HybridEcdh.cpp
autonomous: true
user_setup: []

must_haves:
  truths:
    - "computeSecretRaw accepts 33-byte compressed or 65-byte uncompressed public key"
    - "computeSecretRaw returns 32-byte shared secret for valid inputs"
    - "computeSecretRaw validates public key is on secp256k1 curve"
    - "computeSecretRaw throws ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY for invalid keys"
  artifacts:
    - path: "packages/react-native-quick-crypto/cpp/ecdh/HybridEcdh.hpp"
      provides: "computeSecretRaw declaration"
      contains: "computeSecretRaw"
    - path: "packages/react-native-quick-crypto/cpp/ecdh/HybridEcdh.cpp"
      provides: "computeSecretRaw implementation with EVP_PKEY_derive"
      contains: "EVP_PKEY_derive"
  key_links:
    - from: "HybridEcdh.cpp"
      to: "EVP_PKEY_derive API"
      via: "OpenSSL ECDH key exchange"
      pattern: "EVP_PKEY_derive_init.*EVP_PKEY_derive_set_peer.*EVP_PKEY_derive"
    - from: "HybridEcdh.cpp"
      to: "EC_POINT_oct2point"
      via: "Public key validation"
      pattern: "EC_POINT_oct2point"
---

<objective>
Implement computeSecretRaw in C++ for ECDH shared secret derivation.

Purpose: Enable deriving 32-byte shared secrets from secp256k1 key pairs using OpenSSL EVP_PKEY_derive API with proper public key validation.

Output: HybridEcdh C++ class with computeSecretRaw method that validates peer public keys and computes ECDH shared secrets.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-secret-derivation/02-RESEARCH.md

# Existing implementation
@packages/react-native-quick-crypto/cpp/ecdh/HybridEcdh.hpp
@packages/react-native-quick-crypto/cpp/ecdh/HybridEcdh.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add computeSecretRaw declaration to HybridEcdh.hpp</name>
  <files>packages/react-native-quick-crypto/cpp/ecdh/HybridEcdh.hpp</files>
  <action>
Add the computeSecretRaw method declaration to the public section of HybridEcdh class:

```cpp
std::shared_ptr<ArrayBuffer> computeSecretRaw(const std::shared_ptr<ArrayBuffer>& otherPublicKey) override;
```

Add it after the setPrivateKeyRaw declaration (line ~30).
  </action>
  <verify>File compiles (syntax check only at this stage - full build in Plan 02)</verify>
  <done>HybridEcdh.hpp contains computeSecretRaw declaration</done>
</task>

<task type="auto">
  <name>Task 2: Implement computeSecretRaw in HybridEcdh.cpp</name>
  <files>packages/react-native-quick-crypto/cpp/ecdh/HybridEcdh.cpp</files>
  <action>
Implement computeSecretRaw following the pattern from RESEARCH.md. Key implementation steps:

1. Validate input key size (must be 33 or 65 bytes)
2. Import peer public key using EC_POINT_oct2point (validates curve membership - prevents CVE-2024-48930)
3. Create peer EVP_PKEY from validated EC_KEY
4. Use EVP_PKEY_derive to compute shared secret
5. Return 32-byte shared secret

Critical security requirements:
- EC_POINT_oct2point validates the public key is on secp256k1 curve
- Throw "ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY" for invalid keys
- Clean up all OpenSSL resources on all code paths (error or success)
- clearOpenSSLErrors() at start of method

Implementation structure:
```cpp
std::shared_ptr<ArrayBuffer> HybridEcdh::computeSecretRaw(
    const std::shared_ptr<ArrayBuffer>& otherPublicKey) {
  if (!this->pkey) {
    throw std::runtime_error("No key pair available");
  }

  clearOpenSSLErrors();

  // Validate input size (33 for compressed, 65 for uncompressed)
  size_t keyLen = otherPublicKey->size();
  if (keyLen != 33 && keyLen != 65) {
    throw std::runtime_error("ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY");
  }

  // Import peer public key with validation
  EC_KEY* peerEc = EC_KEY_new_by_curve_name(NID_secp256k1);
  if (!peerEc) {
    throw std::runtime_error("Failed to create EC_KEY: " + getOpenSSLError());
  }

  const EC_GROUP* group = EC_KEY_get0_group(peerEc);
  EC_POINT* peerPoint = EC_POINT_new(group);
  if (!peerPoint) {
    EC_KEY_free(peerEc);
    throw std::runtime_error("Failed to create EC_POINT: " + getOpenSSLError());
  }

  // EC_POINT_oct2point validates curve membership (prevents CVE-2024-48930)
  const uint8_t* keyData = static_cast<const uint8_t*>(otherPublicKey->data());
  if (EC_POINT_oct2point(group, peerPoint, keyData, keyLen, nullptr) != 1) {
    EC_POINT_free(peerPoint);
    EC_KEY_free(peerEc);
    throw std::runtime_error("ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY");
  }

  if (EC_KEY_set_public_key(peerEc, peerPoint) != 1) {
    EC_POINT_free(peerPoint);
    EC_KEY_free(peerEc);
    throw std::runtime_error("Failed to set peer public key: " + getOpenSSLError());
  }
  EC_POINT_free(peerPoint);

  EVP_PKEY* peerKey = EVP_PKEY_new();
  if (!peerKey) {
    EC_KEY_free(peerEc);
    throw std::runtime_error("Failed to create peer EVP_PKEY: " + getOpenSSLError());
  }

  if (EVP_PKEY_set1_EC_KEY(peerKey, peerEc) != 1) {
    EVP_PKEY_free(peerKey);
    EC_KEY_free(peerEc);
    throw std::runtime_error("Failed to set peer EC_KEY: " + getOpenSSLError());
  }
  EC_KEY_free(peerEc);

  // Derive shared secret using EVP_PKEY_derive
  EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new(this->pkey, nullptr);
  if (!ctx) {
    EVP_PKEY_free(peerKey);
    throw std::runtime_error("Failed to create derive context: " + getOpenSSLError());
  }

  if (EVP_PKEY_derive_init(ctx) <= 0) {
    EVP_PKEY_CTX_free(ctx);
    EVP_PKEY_free(peerKey);
    throw std::runtime_error("Failed to init derive: " + getOpenSSLError());
  }

  if (EVP_PKEY_derive_set_peer(ctx, peerKey) <= 0) {
    EVP_PKEY_CTX_free(ctx);
    EVP_PKEY_free(peerKey);
    throw std::runtime_error("ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY");
  }

  size_t secretLen;
  if (EVP_PKEY_derive(ctx, nullptr, &secretLen) <= 0) {
    EVP_PKEY_CTX_free(ctx);
    EVP_PKEY_free(peerKey);
    throw std::runtime_error("Failed to get secret length: " + getOpenSSLError());
  }

  auto* secret = new uint8_t[secretLen];
  if (EVP_PKEY_derive(ctx, secret, &secretLen) <= 0) {
    delete[] secret;
    EVP_PKEY_CTX_free(ctx);
    EVP_PKEY_free(peerKey);
    throw std::runtime_error("Failed to derive secret: " + getOpenSSLError());
  }

  EVP_PKEY_CTX_free(ctx);
  EVP_PKEY_free(peerKey);

  return std::make_shared<NativeArrayBuffer>(secret, secretLen, [=]() { delete[] secret; });
}
```
  </action>
  <verify>Code compiles and follows established patterns in existing methods</verify>
  <done>HybridEcdh.cpp contains complete computeSecretRaw implementation with public key validation</done>
</task>

</tasks>

<verification>
1. HybridEcdh.hpp has computeSecretRaw declaration
2. HybridEcdh.cpp has computeSecretRaw implementation
3. Implementation uses EC_POINT_oct2point for public key validation
4. Implementation uses EVP_PKEY_derive for shared secret computation
5. Error handling uses "ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY" message
6. All OpenSSL resources properly freed on all code paths
</verification>

<success_criteria>
1. computeSecretRaw method declared in header
2. computeSecretRaw method implemented in source with EVP_PKEY_derive
3. Public key validation via EC_POINT_oct2point (CVE-2024-48930 protection)
4. Proper error messages matching Node.js error codes
5. RAII-style cleanup on all paths
</success_criteria>

<output>
After completion, create `.planning/phases/02-secret-derivation/02-01-SUMMARY.md`
</output>
