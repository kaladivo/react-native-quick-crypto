---
phase: 02-secret-derivation
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - example/src/tests/ecdh/ecdh_tests.ts
autonomous: false
user_setup: []

must_haves:
  truths:
    - "Two ECDH instances with swapped keys derive identical secrets"
    - "computeSecret works with compressed (33-byte) and uncompressed (65-byte) public keys"
    - "computeSecret with hex encoding returns 64-character hex string"
    - "Invalid public keys throw error with code ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY"
    - "Secret matches known test vector from Node.js"
  artifacts:
    - path: "example/src/tests/ecdh/ecdh_tests.ts"
      provides: "computeSecret test cases"
      contains: "computeSecret"
  key_links:
    - from: "ecdh_tests.ts"
      to: "react-native-quick-crypto"
      via: "import createECDH"
      pattern: "import.*createECDH.*from.*react-native-quick-crypto"
---

<objective>
Add comprehensive computeSecret tests and verify end-to-end functionality.

Purpose: Validate ECDH shared secret derivation works correctly, matches Node.js behavior, and properly rejects invalid public keys.

Output: Complete test suite for computeSecret with verification checkpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-secret-derivation/02-RESEARCH.md

# Depends on Plan 02
@.planning/phases/02-secret-derivation/02-02-SUMMARY.md

# Existing tests
@example/src/tests/ecdh/ecdh_tests.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add computeSecret tests to example app</name>
  <files>example/src/tests/ecdh/ecdh_tests.ts</files>
  <action>
Add computeSecret test cases to the existing ECDH test file. Append after the existing tests:

```typescript
// Test 9: computeSecret derives identical secret for two parties
test(SUITE, 'computeSecret() derives identical secrets for two parties', () => {
  const alice = createECDH('secp256k1');
  const bob = createECDH('secp256k1');

  alice.generateKeys();
  bob.generateKeys();

  const aliceSecret = alice.computeSecret(bob.getPublicKey());
  const bobSecret = bob.computeSecret(alice.getPublicKey());

  expect(aliceSecret).to.have.length(32);
  expect(bobSecret).to.have.length(32);
  expect(Buffer.from(aliceSecret).toString('hex')).to.equal(
    Buffer.from(bobSecret).toString('hex')
  );
  console.log('[ECDH] computeSecret: Alice and Bob derived identical secrets');
});

// Test 10: computeSecret with hex encoding
test(SUITE, 'computeSecret("hex") returns 64-char hex string', () => {
  const alice = createECDH('secp256k1');
  const bob = createECDH('secp256k1');

  alice.generateKeys();
  bob.generateKeys();

  const secret = alice.computeSecret(bob.getPublicKey('hex'), 'hex', 'hex');
  expect(secret).to.be.a('string');
  expect(secret).to.have.length(64); // 32 bytes * 2 hex chars
  console.log('[ECDH] computeSecret hex:', (secret as string).substring(0, 16) + '...');
});

// Test 11: computeSecret with compressed public key
test(SUITE, 'computeSecret() works with compressed public key', () => {
  const alice = createECDH('secp256k1');
  const bob = createECDH('secp256k1');

  alice.generateKeys();
  bob.generateKeys();

  // Use compressed public key (33 bytes)
  const bobCompressed = bob.getPublicKey(undefined, 'compressed');
  expect(bobCompressed).to.have.length(33);

  const secret = alice.computeSecret(bobCompressed);
  expect(secret).to.have.length(32);
  console.log('[ECDH] computeSecret with compressed key succeeded');
});

// Test 12: computeSecret with imported private key
test(SUITE, 'computeSecret() works after setPrivateKey', () => {
  const alice = createECDH('secp256k1');
  alice.generateKeys();
  const alicePriv = alice.getPrivateKey('hex');
  const alicePub = alice.getPublicKey('hex');

  const bob = createECDH('secp256k1');
  bob.generateKeys();
  const bobPub = bob.getPublicKey('hex');

  // Create new instance with imported key
  const aliceReborn = createECDH('secp256k1');
  aliceReborn.setPrivateKey(alicePriv, 'hex');

  const secretOriginal = alice.computeSecret(bobPub, 'hex', 'hex');
  const secretReborn = aliceReborn.computeSecret(bobPub, 'hex', 'hex');

  expect(secretOriginal).to.equal(secretReborn);
  console.log('[ECDH] computeSecret matches after key import');
});

// Test 13: computeSecret throws for invalid public key
test(SUITE, 'computeSecret() throws ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY for invalid key', () => {
  const ecdh = createECDH('secp256k1');
  ecdh.generateKeys();

  // Invalid public key - wrong size
  const invalidKey = Buffer.alloc(32, 0x04);

  try {
    ecdh.computeSecret(invalidKey);
    expect.fail('Should have thrown');
  } catch (e: unknown) {
    const err = e as NodeJS.ErrnoException;
    expect(err.code).to.equal('ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY');
    console.log('[ECDH] Invalid key correctly rejected with error code');
  }
});

// Test 14: computeSecret throws for point not on curve
test(SUITE, 'computeSecret() throws for public key not on curve', () => {
  const ecdh = createECDH('secp256k1');
  ecdh.generateKeys();

  // Create a 65-byte buffer with valid prefix but invalid point
  const invalidPoint = Buffer.alloc(65, 0);
  invalidPoint[0] = 0x04; // uncompressed prefix
  // Rest is zeros, which is not a valid point on secp256k1

  try {
    ecdh.computeSecret(invalidPoint);
    expect.fail('Should have thrown');
  } catch (e: unknown) {
    const err = e as NodeJS.ErrnoException;
    expect(err.code).to.equal('ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY');
    console.log('[ECDH] Point not on curve correctly rejected');
  }
});

// Test 15: computeSecret with known test vector
test(SUITE, 'computeSecret() matches Node.js test vector', () => {
  // Test vector: deterministic keys for reproducible test
  // Alice private key (32 bytes hex)
  const alicePrivHex = 'c9afa9d845ba75166b5c215767b1d6934e50c3db36e89b127b8a622b120f6721';
  // Bob private key (32 bytes hex)
  const bobPrivHex = '1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';

  const alice = createECDH('secp256k1');
  alice.setPrivateKey(alicePrivHex, 'hex');

  const bob = createECDH('secp256k1');
  bob.setPrivateKey(bobPrivHex, 'hex');

  const aliceSecret = alice.computeSecret(bob.getPublicKey());
  const bobSecret = bob.computeSecret(alice.getPublicKey());

  // Both should derive the same secret
  const aliceSecretHex = Buffer.from(aliceSecret).toString('hex');
  const bobSecretHex = Buffer.from(bobSecret).toString('hex');

  expect(aliceSecretHex).to.equal(bobSecretHex);
  expect(aliceSecretHex).to.have.length(64); // 32 bytes = 64 hex chars

  console.log('[ECDH] Test vector secret:', aliceSecretHex);
});
```

Add `import { Buffer } from '@craftzdog/react-native-buffer';` at the top if not already present.
  </action>
  <verify>Tests added to file without syntax errors</verify>
  <done>computeSecret tests added to example app</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete ECDH computeSecret implementation:
- C++ computeSecretRaw with EVP_PKEY_derive and public key validation
- TypeScript computeSecret wrapper with encoding support
- Error handling with Node.js-compatible error codes
- Test suite covering key exchange, encodings, and error cases
  </what-built>
  <how-to-verify>
1. Start the example app on Android or iOS:
   ```bash
   cd example
   bun run android  # or: bun run ios
   ```

2. Navigate to the test runner screen

3. Run the ECDH test suite

4. Verify all tests pass, specifically:
   - Test 9: Two parties derive identical secrets
   - Test 10: Hex encoding works
   - Test 11: Compressed public key works
   - Test 12: Works after setPrivateKey
   - Test 13: Invalid key size throws correct error
   - Test 14: Invalid point throws correct error
   - Test 15: Test vector produces consistent output

5. Note the test vector secret from Test 15 output (for documentation)
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any failures</resume-signal>
</task>

</tasks>

<verification>
1. Tests added to example/src/tests/ecdh/ecdh_tests.ts
2. All computeSecret tests pass in emulator/simulator
3. Two-party key exchange produces identical secrets
4. Compressed and uncompressed public keys both work
5. Invalid keys throw ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY
6. Hex encoding produces 64-character strings
</verification>

<success_criteria>
1. computeSecret derives identical secrets for Alice and Bob
2. Shared secret is exactly 32 bytes
3. Encoding options work (hex, base64, etc.)
4. Compressed (33-byte) public keys accepted
5. Invalid public keys rejected with proper error code
6. All tests pass in example app
</success_criteria>

<output>
After completion, create `.planning/phases/02-secret-derivation/02-03-SUMMARY.md`
</output>
