---
phase: 01-core-ecdh
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - packages/react-native-quick-crypto/src/ecdh.ts
  - packages/react-native-quick-crypto/src/index.ts
autonomous: true

must_haves:
  truths:
    - "createECDH('secp256k1') returns ECDH instance"
    - "generateKeys() returns public key in requested encoding"
    - "getPublicKey() returns Buffer by default"
    - "getPublicKey('hex') returns hex string"
    - "getPublicKey(encoding, 'compressed') returns 33-byte key"
    - "getPublicKey(encoding, 'uncompressed') returns 65-byte key"
    - "getPrivateKey() returns 32-byte Buffer"
    - "setPrivateKey(key) imports key and auto-derives public key"
  artifacts:
    - path: "packages/react-native-quick-crypto/src/ecdh.ts"
      provides: "TypeScript ECDH class matching Node.js API"
      exports: ["ECDH", "createECDH"]
      min_lines: 100
    - path: "packages/react-native-quick-crypto/src/index.ts"
      provides: "Package exports including ECDH"
      contains: "ecdh"
  key_links:
    - from: "src/ecdh.ts"
      to: "src/specs/ecdh.nitro.ts"
      via: "NitroModules.createHybridObject"
      pattern: "createHybridObject.*Ecdh"
    - from: "src/index.ts"
      to: "src/ecdh.ts"
      via: "module export"
      pattern: "from.*ecdh"
---

<objective>
Create the TypeScript ECDH class that wraps the native module, providing Node.js crypto.createECDH API compatibility with proper encoding handling.

Purpose: Exposes ECDH functionality to JavaScript with Node.js-compatible API surface.
Output: Complete ECDH TypeScript implementation with createECDH factory function, exported from package.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-core-ecdh/01-RESEARCH.md
@.planning/phases/01-core-ecdh/01-CONTEXT.md
@.planning/phases/01-core-ecdh/01-02-SUMMARY.md

# Pattern references
@packages/react-native-quick-crypto/src/ed.ts
@packages/react-native-quick-crypto/src/index.ts
@packages/react-native-quick-crypto/src/specs/ecdh.nitro.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ECDH TypeScript class</name>
  <files>packages/react-native-quick-crypto/src/ecdh.ts</files>
  <action>
Create src/ecdh.ts with ECDH class and createECDH factory following 01-RESEARCH.md patterns.

**Imports:**
```typescript
import { NitroModules } from 'react-native-nitro-modules';
import { Buffer } from '@craftzdog/react-native-buffer';
import type { Ecdh } from './specs/ecdh.nitro';
```

**Types:**
```typescript
type ECDHEncoding = 'hex' | 'base64' | 'base64url' | 'latin1' | 'binary';
type ECDHFormat = 'compressed' | 'uncompressed';
```

**ECDH class implementation:**
```typescript
export class ECDH {
  private native: Ecdh;
  private _curve: string;

  constructor(curve: string) {
    this.native = NitroModules.createHybridObject<Ecdh>('Ecdh');
    this._curve = curve;
    this.native.setCurve(curve);
  }

  generateKeys(encoding?: ECDHEncoding, format?: ECDHFormat): Buffer | string {
    this.native.generateKeys();
    return this.getPublicKey(encoding, format);
  }

  getPublicKey(encoding?: ECDHEncoding, format?: ECDHFormat): Buffer | string {
    const formatFlag = format === 'compressed' ? 0 : 1;  // Default: uncompressed
    const raw = this.native.getPublicKeyRaw(formatFlag);
    return this.encodeOutput(raw, encoding);
  }

  getPrivateKey(encoding?: ECDHEncoding): Buffer | string {
    const raw = this.native.getPrivateKeyRaw();
    return this.encodeOutput(raw, encoding);
  }

  setPrivateKey(privateKey: Buffer | string, encoding?: ECDHEncoding): void {
    const keyBuffer = this.decodeInput(privateKey, encoding);
    this.native.setPrivateKeyRaw(keyBuffer);
  }

  private encodeOutput(data: ArrayBuffer, encoding?: ECDHEncoding): Buffer | string {
    const buf = Buffer.from(data);
    if (!encoding) return buf;
    const actualEncoding = encoding === 'binary' ? 'latin1' : encoding;
    return buf.toString(actualEncoding as BufferEncoding);
  }

  private decodeInput(data: Buffer | string, encoding?: ECDHEncoding): ArrayBuffer {
    const buf = typeof data === 'string'
      ? Buffer.from(data, (encoding === 'binary' ? 'latin1' : encoding) as BufferEncoding)
      : Buffer.isBuffer(data) ? data : Buffer.from(data);
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
  }
}
```

**Factory function:**
```typescript
const SUPPORTED_CURVES = ['secp256k1'] as const;

export function createECDH(curveName: string): ECDH {
  if (!SUPPORTED_CURVES.includes(curveName as typeof SUPPORTED_CURVES[number])) {
    const err = new Error(`Unsupported curve: ${curveName}`);
    (err as NodeJS.ErrnoException).code = 'ERR_CRYPTO_INVALID_CURVE';
    throw err;
  }
  return new ECDH(curveName);
}
```

**Node.js API compatibility notes:**
- Default format is 'uncompressed' (65 bytes), NOT 'compressed'
- Binary encoding is alias for latin1
- Return Buffer when no encoding, string when encoding specified
- Match Node.js error codes for invalid curve
  </action>
  <verify>
File exists and exports correct symbols:
- `grep -l "export class ECDH" packages/react-native-quick-crypto/src/ecdh.ts`
- `grep -l "export function createECDH" packages/react-native-quick-crypto/src/ecdh.ts`
- `grep -l "NitroModules.createHybridObject" packages/react-native-quick-crypto/src/ecdh.ts`
  </verify>
  <done>
src/ecdh.ts created with ECDH class implementing generateKeys, getPublicKey, getPrivateKey, setPrivateKey with proper encoding support
  </done>
</task>

<task type="auto">
  <name>Task 2: Export ECDH from package index</name>
  <files>packages/react-native-quick-crypto/src/index.ts</files>
  <action>
Update src/index.ts to export ECDH functionality.

Add import at the top with other API imports:
```typescript
import * as ecdh from './ecdh';
```

Add to QuickCrypto object:
```typescript
const QuickCrypto = {
  ...keys,
  ...blake3,
  ...cipher,
  ...ecdh,    // <-- Add this line
  ...ed,
  // ... rest
};
```

Add named export:
```typescript
export * from './ecdh';
```

This follows the exact pattern used for other modules (cipher, ed, hash, etc).
  </action>
  <verify>
Index exports ECDH:
- `grep -l "from './ecdh'" packages/react-native-quick-crypto/src/index.ts`
- `grep -l "...ecdh" packages/react-native-quick-crypto/src/index.ts`
  </verify>
  <done>
src/index.ts updated to import and export ecdh module, following existing pattern for other modules
  </done>
</task>

</tasks>

<verification>
- [ ] ECDH class constructor takes curve name parameter
- [ ] ECDH class uses NitroModules.createHybridObject<Ecdh>('Ecdh')
- [ ] generateKeys() calls native.generateKeys() then returns getPublicKey()
- [ ] getPublicKey() defaults to format=1 (uncompressed, 65 bytes)
- [ ] getPublicKey('hex', 'compressed') uses format=0 (33 bytes)
- [ ] getPrivateKey() returns raw 32-byte key or encoded string
- [ ] setPrivateKey() decodes input and calls native.setPrivateKeyRaw()
- [ ] createECDH() validates curve name and throws with ERR_CRYPTO_INVALID_CURVE code
- [ ] index.ts imports ecdh module and exports it
</verification>

<success_criteria>
TypeScript ECDH API is complete:
- createECDH('secp256k1') returns functional ECDH instance
- All encoding options work (hex, base64, base64url, latin1, binary)
- Compressed (33-byte) and uncompressed (65-byte) public key formats work
- Package exports createECDH and ECDH class
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-ecdh/01-03-SUMMARY.md`
</output>
