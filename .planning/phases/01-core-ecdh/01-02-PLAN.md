---
phase: 01-core-ecdh
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/react-native-quick-crypto/cpp/ecdh/HybridEcdh.cpp
autonomous: true

must_haves:
  truths:
    - "generateKeys() creates a valid secp256k1 key pair"
    - "getPublicKeyRaw(0) returns exactly 33 bytes (compressed)"
    - "getPublicKeyRaw(1) returns exactly 65 bytes (uncompressed)"
    - "getPrivateKeyRaw() returns exactly 32 bytes"
    - "setPrivateKeyRaw() accepts 32-byte key and derives public key"
  artifacts:
    - path: "packages/react-native-quick-crypto/cpp/ecdh/HybridEcdh.cpp"
      provides: "Complete ECDH cryptographic operations"
      contains: "EC_POINT_point2oct"
      min_lines: 150
  key_links:
    - from: "setPrivateKeyRaw"
      to: "EC_POINT_mul"
      via: "public key derivation"
      pattern: "EC_POINT_mul.*group.*priv_bn"
    - from: "getPublicKeyRaw"
      to: "EC_POINT_point2oct"
      via: "EC point serialization"
      pattern: "EC_POINT_point2oct"
---

<objective>
Implement all C++ ECDH cryptographic operations: key generation, raw key export (public/private), and private key import with public key auto-derivation.

Purpose: Provides the native cryptographic foundation for the Node.js ECDH API.
Output: Fully functional C++ ECDH implementation using OpenSSL EC APIs.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-core-ecdh/01-RESEARCH.md
@.planning/phases/01-core-ecdh/01-01-SUMMARY.md

# Implementation file
@packages/react-native-quick-crypto/cpp/ecdh/HybridEcdh.cpp
@packages/react-native-quick-crypto/cpp/ecdh/HybridEcdh.hpp

# Pattern references
@packages/react-native-quick-crypto/cpp/ed25519/HybridEdKeyPair.cpp
@packages/react-native-quick-crypto/cpp/utils/Utils.hpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement generateKeys and key export methods</name>
  <files>packages/react-native-quick-crypto/cpp/ecdh/HybridEcdh.cpp</files>
  <action>
Implement the key generation and export methods in HybridEcdh.cpp.

**generateKeys() implementation:**
1. Clean up existing pkey if not nullptr (EVP_PKEY_free)
2. Create EC_KEY with NID_secp256k1: `EC_KEY_new_by_curve_name(NID_secp256k1)`
3. Generate key: `EC_KEY_generate_key(ec)`
4. Wrap in EVP_PKEY: `EVP_PKEY_new()` then `EVP_PKEY_set1_EC_KEY(pkey, ec)`
5. Free EC_KEY (EVP_PKEY has its own reference)
6. Throw on any failure with descriptive error using getOpenSSLError()

**getPublicKeyRaw(format) implementation:**
Use 01-RESEARCH.md Pattern 3 exactly:
1. Check pkey not nullptr, throw "No key pair generated" if null
2. Get EC_KEY: `EVP_PKEY_get0_EC_KEY(pkey)`
3. Get group and public point: `EC_KEY_get0_group`, `EC_KEY_get0_public_key`
4. Determine conversion form: format==0 -> POINT_CONVERSION_COMPRESSED, else POINT_CONVERSION_UNCOMPRESSED
5. Get size: `EC_POINT_point2oct(group, pub_point, conv_form, nullptr, 0, nullptr)`
6. Allocate buffer, export: `EC_POINT_point2oct(group, pub_point, conv_form, buf, len, nullptr)`
7. Return NativeArrayBuffer with cleanup lambda

**getPrivateKeyRaw() implementation:**
Use 01-RESEARCH.md Pattern 3:
1. Check pkey not nullptr
2. Get EC_KEY and private key BIGNUM: `EC_KEY_get0_private_key`
3. Allocate 32-byte buffer
4. Export with padding: `BN_bn2binpad(priv_bn, buf, 32)`
5. Return NativeArrayBuffer with cleanup lambda

**Important OpenSSL patterns:**
- Use RAII where possible (unique_ptr with custom deleters for EVP_PKEY*, EC_KEY*)
- Clear OpenSSL errors before operations: `clearOpenSSLErrors()` (from Utils.hpp)
- Use `getOpenSSLError()` for error messages (from Utils.hpp)
  </action>
  <verify>
Code compiles and follows patterns:
- grep for "EC_POINT_point2oct" in HybridEcdh.cpp
- grep for "BN_bn2binpad" in HybridEcdh.cpp
- grep for "EC_KEY_generate_key" in HybridEcdh.cpp
  </verify>
  <done>
generateKeys(), getPublicKeyRaw(), and getPrivateKeyRaw() are implemented with proper OpenSSL EC API usage
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement setPrivateKeyRaw with public key derivation</name>
  <files>packages/react-native-quick-crypto/cpp/ecdh/HybridEcdh.cpp</files>
  <action>
Implement setPrivateKeyRaw following 01-RESEARCH.md Pattern 4 exactly.

**setPrivateKeyRaw(privateKey) implementation:**
1. Validate input size is exactly 32 bytes, throw "Invalid private key size" if not
2. Clean up existing pkey if not nullptr
3. Create EC_KEY: `EC_KEY_new_by_curve_name(NID_secp256k1)`
4. Convert bytes to BIGNUM: `BN_bin2bn(data, 32, nullptr)`
5. Validate private key range [1, n-1]:
   - Get curve order: `EC_GROUP_get_order(group, order, nullptr)`
   - Check: `!BN_is_zero(priv_bn) && BN_cmp(priv_bn, order) < 0`
   - Throw "Private key out of range" on failure
6. Set private key: `EC_KEY_set_private_key(ec, priv_bn)`
7. Derive public key:
   - Create EC_POINT: `EC_POINT_new(group)`
   - Multiply: `EC_POINT_mul(group, pub_point, priv_bn, nullptr, nullptr, nullptr)`
   - Set: `EC_KEY_set_public_key(ec, pub_point)`
8. Wrap in EVP_PKEY: `EVP_PKEY_new()` then `EVP_PKEY_set1_EC_KEY(pkey, ec)`
9. Cleanup: Free EC_POINT, BIGNUM, EC_KEY (in reverse order of creation)

**Error handling:**
- Every OpenSSL call must be checked for failure
- On failure, clean up all allocated resources before throwing
- Use descriptive error messages that help debugging

**Memory safety:**
- Use RAII patterns where possible
- Ensure no memory leaks on any error path
- BN_free for BIGNUMs, EC_POINT_free for points, EC_KEY_free for keys
  </action>
  <verify>
Code compiles and includes all required operations:
- grep for "EC_POINT_mul" in HybridEcdh.cpp
- grep for "BN_bin2bn" in HybridEcdh.cpp
- grep for "EC_KEY_set_public_key" in HybridEcdh.cpp
  </verify>
  <done>
setPrivateKeyRaw() is implemented: accepts 32-byte private key, validates range, derives and sets public key using EC_POINT_mul
  </done>
</task>

</tasks>

<verification>
- [ ] generateKeys() creates EC key pair for secp256k1
- [ ] getPublicKeyRaw(0) uses POINT_CONVERSION_COMPRESSED
- [ ] getPublicKeyRaw(1) uses POINT_CONVERSION_UNCOMPRESSED
- [ ] getPrivateKeyRaw() uses BN_bn2binpad with 32-byte output
- [ ] setPrivateKeyRaw() validates key size (32 bytes)
- [ ] setPrivateKeyRaw() validates key range [1, n-1]
- [ ] setPrivateKeyRaw() derives public key via EC_POINT_mul
- [ ] All methods check for null pkey before operations
- [ ] All error paths clean up resources before throwing
</verification>

<success_criteria>
All C++ ECDH operations are implemented:
- Key generation produces valid secp256k1 key pairs
- Public key export works in both compressed (33 bytes) and uncompressed (65 bytes) formats
- Private key export returns exactly 32 bytes
- Private key import validates range and auto-derives public key
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-ecdh/01-02-SUMMARY.md`
</output>
