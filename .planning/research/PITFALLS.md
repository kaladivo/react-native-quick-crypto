# Pitfalls Research: ECDH Implementation with secp256k1

**Domain:** Elliptic Curve Diffie-Hellman key exchange
**Curve:** secp256k1
**Researched:** 2026-01-18
**Overall Confidence:** HIGH

This document catalogs common implementation mistakes, security vulnerabilities, and compatibility issues when implementing ECDH with secp256k1, specifically for the React Native Quick Crypto library using OpenSSL 3.6+.

---

## Security Pitfalls

### 1. Missing Public Key Validation (CRITICAL)

- **Risk:** Without validating that received public keys are valid points on the secp256k1 curve, attackers can submit malicious points to extract private keys. CVE-2024-48930 demonstrated this in secp256k1-node where attackers could extract private keys from as few as 11 ECDH sessions.

- **Warning signs:**
  - `computeSecret()` accepts any byte array without validation
  - No curve membership check (point satisfies y^2 = x^3 + 7 mod p)
  - Compressed public key decompression without overflow checks on y-coordinate
  - Tests pass with obviously invalid public keys (all zeros, random bytes)

- **Prevention:**
  1. Verify public key format (correct length: 33 bytes compressed, 65 bytes uncompressed)
  2. Check curve membership: the point must satisfy the curve equation
  3. Verify point is not the point at infinity (identity element)
  4. Use OpenSSL's `EC_KEY_check_key()` or equivalent before ECDH operations
  5. Throw `ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY` matching Node.js behavior

- **Phase:** Implementation (computeSecret method)

- **OpenSSL Pattern:**
  ```cpp
  // OpenSSL 3.x performs validation when setting peer key
  // EVP_PKEY_derive_set_peer validates the peer key
  if (EVP_PKEY_derive_set_peer(ctx, peer_key) <= 0) {
    // Invalid peer key - throw error
  }
  ```

### 2. Small Subgroup Attacks

- **Risk:** secp256k1 has cofactor 1, so it's not directly vulnerable to cofactor attacks, but low-order points from invalid curves can still leak private key bits. Attackers use the Chinese Remainder Theorem to combine partial information from multiple exchanges.

- **Warning signs:**
  - No point order validation
  - Accepting points that aren't generated by the curve's base point
  - Tests only use legitimately generated keys

- **Prevention:**
  1. Validate point lies on the correct curve (not a twist or different curve)
  2. For secp256k1, confirm cofactor handling (though it's 1, the code pattern matters)
  3. Check OpenSSL's `EVP_PKEY_derive_set_peer()` performs these checks

- **Phase:** Implementation (computeSecret method)

### 3. Using Raw Shared Secret Directly

- **Risk:** ECDH shared secrets are x-coordinates of elliptic curve points, which are not uniformly distributed in the key space. Using them directly as encryption keys introduces cryptographic weaknesses.

- **Warning signs:**
  - Documentation examples using `computeSecret()` output directly with `createCipheriv()`
  - No mention of key derivation in API docs
  - Tests that encrypt with raw shared secret

- **Prevention:**
  1. Document clearly that shared secrets should be passed through a KDF (HKDF, SHA-256)
  2. Consider providing a built-in KDF option (like X963KDF)
  3. Update documentation examples to always use key derivation

- **Phase:** Documentation and examples

### 4. Leading Zero Bytes in Shared Secret

- **Risk:** The x-coordinate of the shared point may have leading zero bytes. Some implementations strip these, others preserve them. This creates interoperability issues and potential timing side-channels if implementations compare-and-pad.

- **Warning signs:**
  - Shared secret sometimes 31 bytes instead of 32
  - Different shared secrets between implementations for same key pairs
  - Timing variations when processing shared secrets

- **Prevention:**
  1. Always return fixed-size output (32 bytes for secp256k1)
  2. Pad with leading zeros if needed
  3. Match Node.js behavior exactly (preserves leading zeros)
  4. Test with key pairs known to produce leading-zero secrets

- **Phase:** Implementation and testing

### 5. All-Zero Shared Secret

- **Risk:** Certain invalid public keys can produce an all-zero shared secret, which would be catastrophically weak as a key. This is more relevant for curves with cofactor > 1 but should be checked regardless.

- **Warning signs:**
  - No check for zero output from key agreement
  - Tests don't include edge cases for degenerate keys

- **Prevention:**
  1. Check if shared secret is all zeros before returning
  2. If all-zero, throw an error (indicates invalid input)
  3. This is a secondary defense after public key validation

- **Phase:** Implementation (computeSecret method)

### 6. Private Key Validation Gaps

- **Risk:** `setPrivateKey()` may accept invalid private keys (zero, greater than curve order, etc.) which could lead to weak or predictable shared secrets.

- **Warning signs:**
  - `setPrivateKey(Buffer.alloc(32, 0))` succeeds
  - Private keys larger than curve order accepted
  - No validation error when setting malformed private keys

- **Prevention:**
  1. Validate private key is in range [1, n-1] where n is curve order
  2. Match Node.js: "ecdh.setPrivateKey() now also validates that the private key is valid for the selected curve"
  3. Use `EC_KEY_check_key()` after setting

- **Phase:** Implementation (setPrivateKey method)

---

## Compatibility Pitfalls

### 7. Node.js API Differences

- **Risk:** Subtle differences from Node.js behavior will break drop-in compatibility, which is a core requirement.

- **Warning signs:**
  - Error message text doesn't match Node.js
  - Different encoding support (missing base64url)
  - Different default output format
  - Edge cases behave differently

- **Prevention:**
  1. Match Node.js error codes exactly:
     - `ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY` for invalid public keys
     - `ERR_INVALID_ARG_TYPE` for wrong argument types
  2. Support all encodings Node.js supports: 'hex', 'base64', 'base64url', 'latin1', Buffer
  3. Test against Node.js crypto output directly
  4. Document any intentional differences

- **Phase:** API design and testing

### 8. Public Key Format Mismatches

- **Risk:** Different systems use different public key formats (compressed vs uncompressed). Node.js ECDH supports both input and output formats.

- **Warning signs:**
  - Only 65-byte uncompressed keys work
  - Compressed keys (33 bytes) rejected
  - `getPublicKey('compressed')` not supported
  - Format parameter ignored

- **Prevention:**
  1. Support all three formats: 'compressed', 'uncompressed', 'hybrid'
  2. `getPublicKey(encoding, format)` must support format parameter
  3. `computeSecret()` must accept both compressed and uncompressed peer keys
  4. Use OpenSSL's `EC_POINT_point2oct()` with correct format flags

- **Phase:** Implementation (getPublicKey, computeSecret)

### 9. setPrivateKey Auto-Derives Public Key

- **Risk:** In Node.js, calling `setPrivateKey()` automatically computes and stores the corresponding public key. Missing this behavior breaks code that calls `setPrivateKey()` then `getPublicKey()`.

- **Warning signs:**
  - `setPrivateKey()` works but `getPublicKey()` returns undefined or throws
  - Need to call `generateKeys()` even after `setPrivateKey()`
  - Inconsistent state after `setPrivateKey()`

- **Prevention:**
  1. `setPrivateKey()` must compute and store public key
  2. Validate that private key produces a valid public point
  3. Test: `ecdh.setPrivateKey(privKey); const pubKey = ecdh.getPublicKey();` must work

- **Phase:** Implementation (setPrivateKey method)

### 10. setPublicKey Deprecation and Behavior

- **Risk:** Node.js deprecated `setPublicKey()` in v5.2.0 but still supports it. Some code relies on it for format conversion (compressed to uncompressed).

- **Warning signs:**
  - `setPublicKey()` throws instead of working (even if deprecated)
  - `setPublicKey()` doesn't validate the key
  - State becomes inconsistent after `setPublicKey()` without matching private key

- **Prevention:**
  1. Implement `setPublicKey()` but mark as deprecated
  2. Validate the public key when setting
  3. Warn that ECDH state may be inconsistent (no private key)
  4. Match Node.js behavior exactly for compatibility

- **Phase:** Implementation (setPublicKey method - lower priority)

---

## OpenSSL-Specific Pitfalls

### 11. Deprecated OpenSSL APIs

- **Risk:** Using deprecated ECDH APIs will fail in OpenSSL 3.x or produce security warnings. The project requires OpenSSL 3.6+ EVP-only approach.

- **Warning signs:**
  - Using `ECDH_compute_key()` (deprecated)
  - Using `EC_KEY_*` low-level functions directly for key agreement
  - Compiler deprecation warnings from OpenSSL

- **Prevention:**
  1. Use only EVP APIs:
     - `EVP_PKEY_derive_init()`
     - `EVP_PKEY_derive_set_peer()`
     - `EVP_PKEY_derive()`
  2. For key generation: `EVP_PKEY_keygen()` with EC parameters
  3. Reference existing `HybridEcKeyPair.cpp` for patterns

- **Phase:** Implementation (all C++ code)

### 12. EVP Context Lifecycle Management

- **Risk:** Improper EVP context management causes memory leaks, use-after-free, or incomplete operations.

- **Warning signs:**
  - `EVP_PKEY_CTX` not freed
  - Context reused without reinitializing
  - Missing error checks after EVP calls
  - Double-free or use-after-free in error paths

- **Prevention:**
  1. Use RAII wrappers: `std::unique_ptr<EVP_PKEY_CTX, decltype(&EVP_PKEY_CTX_free)>`
  2. Check return values of all EVP functions (non-positive = error)
  3. Never reuse derivation context for multiple operations
  4. Follow pattern in existing `HybridEcKeyPair.cpp`

- **Phase:** Implementation (C++ layer)

### 13. Peer Key Parameter Validation in OpenSSL

- **Risk:** OpenSSL's `EVP_PKEY_derive_set_peer()` requires peer key to use the same curve parameters. Mismatched curves cause silent failures or incorrect results.

- **Warning signs:**
  - Computing secrets between keys from different curves "works"
  - No error when peer key has different parameters
  - Shared secrets don't match between parties

- **Prevention:**
  1. Verify both keys use same curve before derivation
  2. OpenSSL's `EVP_PKEY_derive_set_peer()` should check this
  3. Add explicit curve comparison if OpenSSL doesn't
  4. Clear error message: "ECDH requires same curve for both keys"

- **Phase:** Implementation (computeSecret)

### 14. OSSL_PARAM Configuration for ECDH

- **Risk:** OpenSSL 3.x uses OSSL_PARAM for configuration. Incorrect parameters cause subtle failures or insecure defaults.

- **Warning signs:**
  - Not setting `OSSL_EXCHANGE_PARAM_PAD` for fixed-length output
  - Incorrect cofactor mode for FIPS compliance
  - KDF parameters set but no effect

- **Prevention:**
  1. For raw ECDH (no KDF), padding should ensure fixed output size
  2. Check `OSSL_EXCHANGE_PARAM_PAD` usage
  3. Test output is always 32 bytes for secp256k1
  4. Document parameter choices

- **Phase:** Implementation (C++ layer)

### 15. Error Extraction from OpenSSL

- **Risk:** OpenSSL errors in the error queue aren't extracted, leading to generic error messages that don't help debugging.

- **Warning signs:**
  - All errors say "operation failed" without specifics
  - OpenSSL error queue fills up
  - Hard to debug key validation failures

- **Prevention:**
  1. Always call `ERR_get_error()` after failures
  2. Convert OpenSSL errors to meaningful messages
  3. Clear error queue appropriately
  4. Don't leak sensitive info in errors (key values)

- **Phase:** Implementation (error handling)

---

## secp256k1-Specific Pitfalls

### 16. Curve Name Mapping

- **Risk:** secp256k1 has multiple names. Inconsistent mapping causes "curve not found" errors or wrong curve used.

- **Warning signs:**
  - `createECDH('secp256k1')` fails
  - Only OpenSSL internal names work
  - Inconsistency with Node.js naming

- **Prevention:**
  1. Support all names: 'secp256k1' (primary), NID_secp256k1
  2. Map in curve name resolver (see existing `GetCurveFromName()`)
  3. Match Node.js: `crypto.getCurves()` includes 'secp256k1'
  4. Test both name styles

- **Phase:** Implementation (createECDH)

### 17. Key Size Assumptions

- **Risk:** secp256k1 has specific sizes that differ from P-256. Hardcoded assumptions cause failures.

- **Warning signs:**
  - Magic number 32 used without context
  - Private key assumed 32 bytes (correct but should be named constant)
  - Public key size confusion (32 vs 33 vs 65)

- **Prevention:**
  1. Define named constants:
     - `SECP256K1_PRIVATE_KEY_SIZE = 32`
     - `SECP256K1_PUBLIC_KEY_COMPRESSED_SIZE = 33`
     - `SECP256K1_PUBLIC_KEY_UNCOMPRESSED_SIZE = 65`
     - `SECP256K1_SHARED_SECRET_SIZE = 32`
  2. Use constants consistently
  3. Validate input sizes explicitly

- **Phase:** Implementation (all methods)

### 18. secp256k1 vs NIST Curve Behavior Differences

- **Risk:** Code tested only with P-256 may fail with secp256k1 due to subtle differences in handling.

- **Warning signs:**
  - Tests only use P-256
  - secp256k1 listed as supported but not tested
  - Different error messages for secp256k1

- **Prevention:**
  1. Test matrix must include secp256k1 explicitly
  2. Test key generation, import, export, computeSecret for secp256k1
  3. Verify against Wycheproof secp256k1 test vectors
  4. Ensure JWK export uses "secp256k1" crv value (not mapped to NIST name)

- **Phase:** Testing

### 19. Blockchain Ecosystem Compatibility

- **Risk:** secp256k1 is heavily used in Bitcoin/Ethereum. Those ecosystems have specific conventions that differ from generic ECDH.

- **Warning signs:**
  - Keys from Bitcoin libraries don't work
  - Ethereum-generated keys produce different shared secrets
  - DER format vs raw format confusion

- **Prevention:**
  1. Support raw key format (not just DER/SPKI/PKCS8)
  2. Test interop with `@noble/secp256k1` or similar
  3. Document any format requirements
  4. Consider supporting Bitcoin-style key formats in future

- **Phase:** Testing and documentation

---

## Test Vectors

### Authoritative Sources

1. **Wycheproof Project** (HIGH confidence)
   - Location: `https://github.com/C2SP/wycheproof/blob/main/testvectors/ecdh_secp256k1_test.json`
   - Contains: Valid/invalid key pairs, edge cases, malicious inputs
   - Use for: Security validation, edge case testing

2. **Node.js Test Suite** (HIGH confidence)
   - Location: Node.js repository `test/parallel/test-crypto-ecdh.js`
   - Contains: API compatibility tests, encoding tests
   - Use for: Node.js behavior matching

3. **Project-specific test vectors** (to be created)
   - Generate test vectors using Node.js crypto
   - Include: key generation, import/export, computeSecret
   - Store in: `example/src/tests/ecdh/`

### Test Categories Needed

| Category | Purpose | Vector Source |
|----------|---------|---------------|
| Valid key exchange | Basic functionality | Node.js, Wycheproof |
| Invalid public keys | Security validation | Wycheproof |
| Format conversion | Compressed/uncompressed | Custom |
| Encoding round-trip | hex, base64, buffer | Node.js |
| Error handling | Match Node.js errors | Node.js |
| Edge cases | Leading zeros, max values | Wycheproof |

---

## Phase-Specific Checklist

### Phase: API Design
- [ ] Node.js API signature match verified
- [ ] All method signatures documented
- [ ] Error codes match Node.js

### Phase: Implementation
- [ ] Public key validation implemented
- [ ] Private key validation implemented
- [ ] Fixed-length output with leading zero preservation
- [ ] EVP-only OpenSSL APIs used
- [ ] RAII for all OpenSSL resources
- [ ] Curve name mapping complete

### Phase: Testing
- [ ] Wycheproof secp256k1 vectors pass
- [ ] Node.js compatibility tests pass
- [ ] Edge case tests (zeros, max values)
- [ ] Error path tests
- [ ] Cross-platform verification

### Phase: Documentation
- [ ] KDF usage emphasized
- [ ] Security best practices documented
- [ ] API differences from Node.js noted (if any)

---

## Sources

**Security Research:**
- [Hacken: Securing ECDH in Secp256k1](https://hacken.io/insights/secure-ecdh/) - Small subgroup attack analysis
- [CVE-2024-48930](https://github.com/advisories/GHSA-584q-6j8j-r5pm) - secp256k1-node private key extraction
- [ECDH Security Considerations Gist](https://gist.github.com/mimoo/435baab9545c03225de8bafff30c9b4b) - Point validation, shared secret handling

**Implementation References:**
- [OpenSSL Wiki: Elliptic Curve Diffie Hellman](https://wiki.openssl.org/index.php/Elliptic_Curve_Diffie_Hellman) - EVP API patterns
- [OpenSSL EVP_KEYEXCH-ECDH](https://docs.openssl.org/master/man7/EVP_KEYEXCH-ECDH/) - Official documentation
- [Node.js Crypto Documentation](https://nodejs.org/api/crypto.html) - API reference

**Test Vectors:**
- [Wycheproof Project](https://github.com/C2SP/wycheproof) - Cryptographic test vectors
- [Wycheproof Testing Handbook](https://appsec.guide/docs/crypto/wycheproof/) - Usage guide

---

*Pitfalls research: 2026-01-18*
*Confidence: HIGH - Based on documented vulnerabilities, official documentation, and established security research*
